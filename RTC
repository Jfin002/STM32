Main.c:
#include <stdio.h>
#include "rtc.h"
#include "uart.h"

#define BUFF_LEN 20

uint8_t hour,min,sec;
uint8_t day,month,year;

uint8_t time_buff[BUFF_LEN] = {0};
uint8_t date_buff[BUFF_LEN] = {0};

static void display_rtc_calendar(void);

int main(void)
{
 /*Initialize debug UART*/
  UART2_TX_Init();
 /*Initialize rtc*/
 rtc_init();
 while(1)
	 {
	 display_rtc_calendar();
	 }
}
static void display_rtc_calendar(void)
{

	hour = rtc_convert_bcd2dec(rtc_time_get_hour());
	min = rtc_convert_bcd2dec(rtc_time_get_minute());
	sec = rtc_convert_bcd2dec(rtc_time_get_second());

	month = rtc_convert_bcd2dec(rtc_date_get_month());
	day = rtc_convert_bcd2dec(rtc_date_get_day());
	year = rtc_convert_bcd2dec(rtc_date_get_year());

 /*Display format : hh : mm : ss*/
 sprintf((char *)time_buff,"%.2d :%.2d :%.2d",hour,min,sec);
 printf("Time : %.2d :%.2d :%.2d\n\r",hour,min,sec);

 /*Display format : mm : dd : yy*/
 sprintf((char *)date_buff,"%.2d - %.2d - %.2d",month,day,year);
 printf("Date : %.2d - %.2d - %.2d ",month,day,year);

}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
UART.c:
#include "uart.h"


#define GPIOAEN     (1<<0)
#define UART2EN     (1<<17)

#define CR1_TE       (1<<3)
#define CR1_UE       (1<<13)
#define SR_TXE       (1<<7)

#define SYS_FREQ     16000000
#define APB1_CLK   SYS_FREQ
#define UART_BAUDRATE   9600


static void uart_set_baudrate(USART_TypeDef *USARRTx,uint32_t PeriphClk, uint32_t BaudRate );
static uint16_t compute_uart_bd(uint32_t PeriphClk, uint32_t BaudRate);

void UART2_write(int ch);

int __io_putchar(int ch)
{
	  UART2_write(ch);
	  return ch;
}


/* CONFIGURE UART GPIO PIN
 * FROM ALTERNATE FN. TABLE 9 USART2_TX ->PA2 -> AF07
	 */

void UART2_TX_Init(void)
{
	 /******CONFIGURE UART GPIO PIN***********/

	 //ENABLE DATA BUS WITH REFERNCE MANUAL 6.3.11
	  RCC ->AHB1ENR |= GPIOAEN;
	//SET PA2 MODE TO ALTERNATE FUNCTION MODE WITH REFERNCE MANUAL 8.4.1
	 GPIOA ->MODER &=~(1<<4);
	 GPIOA ->MODER |=(1<<5);
	/*SET PA2 ALTERNATE FUNCTION TYPE TO UART_TX(AF07)
	 * WITH REFERNCE MANUAL 8.4.9
	 * HERE PA2 -> AFRL2 (BIT 8,9,10,11)
	 * AF7 -> 0111    AFRL ->AFR[0]   AFRH ->AFR[1]
	 */
     GPIOA ->AFR[0]|=(1<<8);
     GPIOA ->AFR[0]|=(1<<9);
     GPIOA ->AFR[0]|=(1<<10);
     GPIOA ->AFR[0]&=~(1<<11);
	 /******CONFIGURE UART MODULE***********/

	//ENBALE CLOCK ACCESS TO UART2
	RCC ->APB1ENR |= UART2EN;
	//CONFIGURE BAUDRATE
	uart_set_baudrate(USART2,APB1_CLK, UART_BAUDRATE );
	//CONFIGURE TRANSFER DIRECTION WITH REFERNCE MANUAL 19.6.4 USART_CR1
	USART2 ->CR1 = CR1_TE;
	// ENABLE UART MODULE WITH CONTROL REGISTER 1
	USART2 ->CR1 |= CR1_UE;


}


void UART2_write(int ch){

   //MAKE SURE THE TRANSMIT DATA TRANSFER IS EMPTY
	while(!(USART2 ->SR & SR_TXE))
	{

	}
	//WRITE TO TRANSMIT DATA REGISTER WITH REFERENCE MANUAL 19.6.1
	USART2 ->DR =(ch &0xFF);

}



static void uart_set_baudrate(USART_TypeDef *USARTx,uint32_t PeriphClk, uint32_t BaudRate )
{
	USARTx ->BRR =compute_uart_bd(PeriphClk,BaudRate);
}

static uint16_t compute_uart_bd(uint32_t PeriphClk, uint32_t BaudRate)
{
	return (PeriphClk + (BaudRate/2U)) /BaudRate;
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
UART.h:
/*
 * uart.h
 *
 *  Created on: Feb 24, 2026
 *      Author: jeffin
 */

#ifndef INC_UART_H_
#define INC_UART_H_

#include "stm32f4xx.h"
#include "stdint.h"

void UART2_TX_Init(void);

#endif /* INC_UART_H_ */
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
RTC.c:

#include "rtc.h"
#define PWREN (1U << 28)
#define CR_DBP (1U << 8)
#define CSR_LSION (1U << 0)
#define CSR_LSIRDY (1U << 1)
#define BDCR_BDRST (1U << 16)
#define BDCR_RTCEN (1U << 15)

#define RTC_WRITE_PROTECTION_KEY_1 ((uint8_t)0xCAU)
#define RTC_WRITE_PROTECTION_KEY_2 ((uint8_t)0x53U)
#define RTC_INIT_MASK 0xFFFFFFFFU
#define ISR_INITF (1U << 6)
#define WEEKDAY_WEDNESDAY ((uint8_t)0x03U)
#define MONTH_FEBRUARY  ((uint8_t)0x02U)
#define TIME_FORMAT_PM (1U << 22)
#define CR_FMT (1U << 6)
#define ISR_RSF (1U << 5)
#define RTC_ASYNCH_PREDIV ((uint32_t)0x7F)
#define RTC_SYNCH_PREDIV ((uint32_t)0x00F9)

static void rtc_set_asynch_prescaler(uint32_t AsynchPrescaler)
{
 MODIFY_REG(RTC->PRER, RTC_PRER_PREDIV_A, AsynchPrescaler << RTC_PRER_PREDIV_A_Pos);
}

static void rtc_set_synch_prescaler(uint32_t SynchPrescaler)
{
 MODIFY_REG(RTC->PRER, RTC_PRER_PREDIV_S, SynchPrescaler);
}

void _rtc_enable_init_mode(void)
{
 RTC->ISR = RTC_INIT_MASK;
}

void _rtc_disable_init_mode(void)
{
 RTC->ISR = ~RTC_INIT_MASK;
}

uint8_t _rtc_isActiveflag_init(void)
{
 return ((RTC->ISR & ISR_INITF) == ISR_INITF);
}

uint8_t _rtc_isActiveflag_rs(void)
{
 return ((RTC->ISR & ISR_RSF) == ISR_RSF);
}

static uint8_t rtc_init_seq(void)
{
 /* Start init mode */
 _rtc_enable_init_mode();
 /* Wait till we are in init mode */
 while (_rtc_isActiveflag_init() != 1) {}
 return 1;
}

static uint8_t wait_for_synchro(void)
{
 /* Clear RSF */
 RTC->ISR &= ~ISR_RSF;
 /* Wait for registers to synchronize */
 while (_rtc_isActiveflag_rs() != 1) {}
 return 1;
}

static uint8_t exit_init_seq(void)
{
 /* Stop init mode */
 _rtc_disable_init_mode();
 /* Wait for registers to synchronize */
 return (wait_for_synchro());
}

static void rtc_date_config(uint32_t WeekDay, uint32_t Day, uint32_t
Month, uint32_t Year)
{
 register uint32_t temp = 0U;
 temp = (WeekDay << RTC_DR_WDU_Pos) |\
 (((Year & 0xF0U) << (RTC_DR_YT_Pos - 4U)) | ((Year & 0x0FU) << RTC_DR_YU_Pos)) |\
 (((Month & 0xF0U) << (RTC_DR_MT_Pos - 4U)) | ((Month & 0x0FU) << RTC_DR_MU_Pos)) |\
 (((Day & 0xF0U) << (RTC_DR_DT_Pos - 4U)) | ((Day & 0x0FU) << RTC_DR_DU_Pos));
 MODIFY_REG(RTC->DR, (RTC_DR_WDU | RTC_DR_MT | RTC_DR_MU | RTC_DR_DT | RTC_DR_DU | RTC_DR_YT | RTC_DR_YU), temp);
}

static void rtc_time_config(uint32_t Format12_24, uint32_t Hours, uint32_t Minutes, uint32_t Seconds)
{
 register uint32_t temp = 0U;
 temp = Format12_24 |\
 (((Hours & 0xF0U) << (RTC_TR_HT_Pos - 4U)) | ((Hours & 0x0FU) << RTC_TR_HU_Pos)) |\
 (((Minutes & 0xF0U) << (RTC_TR_MNT_Pos - 4U)) | ((Minutes & 0x0FU) << RTC_TR_MNU_Pos)) |\
 (((Seconds & 0xF0U) << (RTC_TR_ST_Pos - 4U)) | ((Seconds & 0x0FU) << RTC_TR_SU_Pos));
 MODIFY_REG(RTC->TR, (RTC_TR_PM | RTC_TR_HT | RTC_TR_HU | RTC_TR_MNT | RTC_TR_MNU | RTC_TR_ST | RTC_TR_SU), temp);
}

void rtc_init(void)
{
 /* Enable clock access to PWR */
 RCC->APB1ENR |= PWREN;
 /* Enable Backup access to config RTC */
 PWR->CR |= CR_DBP;
 /* Enable Low Speed Internal (LSI) */
 RCC->CSR |= CSR_LSION;
 /* Wait for LSI to be ready */
 while((RCC->CSR & CSR_LSIRDY) != CSR_LSIRDY) {}
 /* Force backup domain reset */
 RCC->BDCR |= BDCR_BDRST;
 /* Release backup domain reset */
 RCC->BDCR &= ~BDCR_BDRST;
 /* Set RTC clock source to LSI */
 RCC->BDCR &= ~(1U << 8);
 RCC->BDCR |= (1U << 9);
 /* Enable the RTC */
 RCC->BDCR |= BDCR_RTCEN;
 /* Disable RTC registers write protection */
 RTC->WPR = RTC_WRITE_PROTECTION_KEY_1;
 RTC->WPR = RTC_WRITE_PROTECTION_KEY_2;
 /* Enter the initialization mode */
 if(rtc_init_seq() != 1)
 {
 // Handle initialization failure
 }
 /* Set desired date: Friday, December 29th, 2016 */
 rtc_date_config(WEEKDAY_WEDNESDAY, 0x24, MONTH_FEBRUARY, 0x26);
 /* Set desired time: 11:59:55 PM */
 rtc_time_config(TIME_FORMAT_PM, 0x11, 0x38, 0x32);
 /* Set hour format */
 RTC->CR |= CR_FMT;
 /* Set Asynchronous prescaler */
 rtc_set_asynch_prescaler(RTC_ASYNCH_PREDIV);
 /* Set Synchronous prescaler */
 rtc_set_synch_prescaler(RTC_SYNCH_PREDIV);
 /* Exit the initialization mode */
 exit_init_seq();
 /* Enable RTC registers write protection */
 RTC->WPR = 0xFF;
}

uint8_t rtc_convert_dec2bcd(uint8_t value)
{
 return (uint8_t)((((value) / 10U) << 4U) | ((value) % 10U));
}

uint8_t rtc_convert_bcd2dec(uint8_t value)
{
 return (uint8_t)(((uint8_t)((value) & (uint8_t)0xF0U) >> (uint8_t)0x4U) * 10U + ((value) & (uint8_t)0x0FU));
}

uint32_t rtc_date_get_day(void)
{
 return (uint32_t)((READ_BIT(RTC->DR, (RTC_DR_DT | RTC_DR_DU))) >> RTC_DR_DU_Pos);
}

uint32_t rtc_date_get_year(void)
{
 return (uint32_t)((READ_BIT(RTC->DR, (RTC_DR_YT | RTC_DR_YU))) >> RTC_DR_YU_Pos);
}

uint32_t rtc_date_get_month(void)
{
 return (uint32_t)((READ_BIT(RTC->DR, (RTC_DR_MT | RTC_DR_MU))) >> RTC_DR_MU_Pos);
}

uint32_t rtc_time_get_second(void)
{
 return (uint32_t)(READ_BIT(RTC->TR, (RTC_TR_ST | RTC_TR_SU))>> RTC_TR_SU_Pos);
}

uint32_t rtc_time_get_minute(void)
{
 return (uint32_t)(READ_BIT(RTC->TR, (RTC_TR_MNT | RTC_TR_MNU)) >> RTC_TR_MNU_Pos);
}

uint32_t rtc_time_get_hour(void)
{
 return (uint32_t)((READ_BIT(RTC->TR, (RTC_TR_HT | RTC_TR_HU))) >> RTC_TR_HU_Pos);
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
RTC.h:
/*
 * rtc.h
 *
 *  Created on: Feb 24, 2026
 *      Author: jeffin
 */

#ifndef INC_RTC_H_
#define INC_RTC_H_

#include <stdint.h>
#include "stm32f4xx.h"

void rtc_init(void);

uint8_t rtc_convert_bcd2dec(uint8_t value);
uint8_t rtc_convert_dec2bcd(uint8_t value);

uint32_t rtc_date_get_day(void);
uint32_t rtc_date_get_year(void);
uint32_t rtc_date_get_month(void);

uint32_t rtc_time_get_second(void);
uint32_t rtc_time_get_minute(void);
uint32_t rtc_time_get_hour(void);

#endif /* INC_RTC_H_ */
