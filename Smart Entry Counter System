HAL CODE:

/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Smart Person Entry Monitor Counter - Full Integrated Code
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include <string.h>
#include <stdint.h>
#include <stdio.h>

/* Private variables ---------------------------------------------------------*/
I2C_HandleTypeDef hi2c1;

/* USER CODE BEGIN PV */
#define SSD1306_WIDTH  128
#define SSD1306_HEIGHT 64
#define SSD1306_ADDR   0x78

// Hardware Pins
#define LASER_PORT  GPIOB
#define LASER_PIN   GPIO_PIN_0
#define BUZZER_PORT GPIOB
#define BUZZER_PIN  GPIO_PIN_1
#define LDR_PORT    GPIOA
#define LDR_PIN     GPIO_PIN_1

static uint8_t SSD1306_Buffer[SSD1306_WIDTH * SSD1306_HEIGHT / 8];

// Standard 5x7 ASCII Font
static const uint8_t font5x7[][5] = {
    {0x00,0x00,0x00,0x00,0x00},{0x00,0x00,0x5F,0x00,0x00},{0x00,0x07,0x00,0x07,0x00},{0x14,0x7F,0x14,0x7F,0x14},
    {0x24,0x2A,0x7F,0x2A,0x12},{0x23,0x13,0x08,0x64,0x62},{0x36,0x49,0x55,0x22,0x50},{0x00,0x05,0x03,0x00,0x00},
    {0x00,0x1C,0x22,0x41,0x00},{0x00,0x41,0x22,0x1C,0x00},{0x08,0x2A,0x1C,0x2A,0x08},{0x08,0x08,0x3E,0x08,0x08},
    {0x00,0x50,0x30,0x00,0x00},{0x08,0x08,0x08,0x08,0x08},{0x00,0x60,0x60,0x00,0x00},{0x20,0x10,0x08,0x04,0x02},
    {0x3E,0x51,0x49,0x45,0x3E},{0x00,0x42,0x7F,0x40,0x00},{0x42,0x61,0x51,0x49,0x46},{0x21,0x41,0x45,0x4B,0x31},
    {0x18,0x14,0x12,0x7F,0x10},{0x27,0x45,0x45,0x45,0x39},{0x3C,0x4A,0x49,0x49,0x30},{0x01,0x71,0x09,0x05,0x03},
    {0x36,0x49,0x49,0x49,0x36},{0x06,0x49,0x49,0x29,0x1E},{0x00,0x36,0x36,0x00,0x00},{0x00,0x56,0x36,0x00,0x00},
    {0x00,0x08,0x14,0x22,0x41},{0x14,0x14,0x14,0x14,0x14},{0x41,0x22,0x14,0x08,0x00},{0x02,0x01,0x51,0x09,0x06},
    {0x32,0x49,0x79,0x41,0x3E},{0x7E,0x11,0x11,0x11,0x7E},{0x7F,0x49,0x49,0x49,0x36},{0x3E,0x41,0x41,0x41,0x22},
    {0x7F,0x41,0x41,0x22,0x1C},{0x7F,0x49,0x49,0x49,0x41},{0x7F,0x09,0x09,0x09,0x01},{0x3E,0x41,0x49,0x49,0x7A},
    {0x7F,0x08,0x08,0x08,0x7F},{0x00,0x41,0x7F,0x41,0x00},{0x20,0x40,0x41,0x3F,0x01},{0x7F,0x08,0x14,0x22,0x41},
    {0x7F,0x40,0x40,0x40,0x40},{0x7F,0x02,0x0C,0x02,0x7F},{0x7F,0x04,0x08,0x10,0x7F},{0x3E,0x41,0x41,0x41,0x3E},
    {0x7F,0x09,0x09,0x09,0x06},{0x3E,0x41,0x51,0x21,0x5E},{0x7F,0x09,0x19,0x29,0x46},{0x46,0x49,0x49,0x49,0x31},
    {0x01,0x01,0x7F,0x01,0x01},{0x3F,0x40,0x40,0x40,0x3F},{0x1F,0x20,0x40,0x20,0x1F},{0x3F,0x40,0x38,0x40,0x3F},
    {0x63,0x14,0x08,0x14,0x63},{0x07,0x08,0x70,0x08,0x07},{0x61,0x51,0x49,0x45,0x43}
};
/* USER CODE END PV */

/* Prototypes */
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_I2C1_Init(void);
void ssd1306_WriteCommand(uint8_t cmd);
void ssd1306_Init(void);
void ssd1306_Fill(uint8_t color);
void ssd1306_UpdateScreen(void);
void ssd1306_DrawPixel(uint8_t x, uint8_t y, uint8_t color);
void ssd1306_WriteString(char* str, uint8_t x_start, uint8_t y_start, uint8_t size);
void Buzzer_Beep(uint16_t duration_ms);

/**
  * @brief  Main program entry
  */
int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_I2C1_Init();

  HAL_Delay(500);
  ssd1306_Init();

  // 1. Splash Screen Initialization
  ssd1306_Fill(0);
  ssd1306_WriteString("SMART PERSON", 25, 5, 1);
  ssd1306_WriteString("ENTRY MONITOR", 20, 20, 1);
  ssd1306_WriteString("COUNTER", 40, 35, 1);
  ssd1306_UpdateScreen();
  HAL_Delay(3000); // 3-second initial display

  // 2. Turn on Laser
  HAL_GPIO_WritePin(LASER_PORT, LASER_PIN, GPIO_PIN_SET);

  int person_count = 0;
  char count_buf[15];
  uint8_t is_blocked = 0;

  while (1)
  {
    // Update Screen with Current Count
    ssd1306_Fill(0);
    ssd1306_WriteString("PERSON ENTERED", 22, 10, 1);
    sprintf(count_buf, "%d", person_count);
    ssd1306_WriteString(count_buf, 50, 30, 3);
    ssd1306_UpdateScreen();

    // Check LDR Sensor State
    // Digital LDR modules usually output HIGH (SET) when beam is broken (dark)
    if (HAL_GPIO_ReadPin(LDR_PORT, LDR_PIN) == GPIO_PIN_SET)
    {
      if (!is_blocked) { // If it wasn't already blocked
        person_count++;
        Buzzer_Beep(200); // 200ms beep
        is_blocked = 1;   // Prevent re-triggering until beam is restored
      }
    }
    else
    {
      is_blocked = 0; // Beam is restored
    }

    HAL_Delay(20); // Fast polling for accuracy
  }
}

/* --- SSD1306 & BUZZER DRIVER FUNCTIONS --- */

void Buzzer_Beep(uint16_t duration_ms) {
    HAL_GPIO_WritePin(BUZZER_PORT, BUZZER_PIN, GPIO_PIN_SET);
    HAL_Delay(duration_ms);
    HAL_GPIO_WritePin(BUZZER_PORT, BUZZER_PIN, GPIO_PIN_RESET);
}

void ssd1306_WriteCommand(uint8_t cmd) {
    uint8_t buffer[2] = {0x00, cmd};
    HAL_I2C_Master_Transmit(&hi2c1, SSD1306_ADDR, buffer, 2, 10);
}

void ssd1306_Init(void) {
    HAL_Delay(100);
    uint8_t init_cmds[] = {
        0xAE, 0xD5, 0x80, 0xA8, 0x3F, 0xD3, 0x00, 0x40, 0x8D, 0x14,
        0x20, 0x00, 0xA1, 0xC8, 0xDA, 0x12, 0x81, 0xCF, 0xD9, 0xF1,
        0xDB, 0x40, 0xA4, 0xA6, 0xAF
    };
    for(uint8_t i=0; i<sizeof(init_cmds); i++) ssd1306_WriteCommand(init_cmds[i]);
    ssd1306_Fill(0);
    ssd1306_UpdateScreen();
}

void ssd1306_Fill(uint8_t color) {
    memset(SSD1306_Buffer, (color ? 0xFF : 0x00), sizeof(SSD1306_Buffer));
}

void ssd1306_UpdateScreen(void) {
    ssd1306_WriteCommand(0x21); ssd1306_WriteCommand(0); ssd1306_WriteCommand(127);
    ssd1306_WriteCommand(0x22); ssd1306_WriteCommand(0); ssd1306_WriteCommand(7);
    uint8_t temp[1025];
    temp[0] = 0x40;
    memcpy(&temp[1], SSD1306_Buffer, 1024);
    HAL_I2C_Master_Transmit(&hi2c1, SSD1306_ADDR, temp, 1025, 100);
}

void ssd1306_DrawPixel(uint8_t x, uint8_t y, uint8_t color) {
    if(x >= SSD1306_WIDTH || y >= SSD1306_HEIGHT) return;
    if(color) SSD1306_Buffer[x + (y/8)*SSD1306_WIDTH] |= (1 << (y%8));
    else      SSD1306_Buffer[x + (y/8)*SSD1306_WIDTH] &= ~(1 << (y%8));
}

void ssd1306_WriteString(char* str, uint8_t x_start, uint8_t y_start, uint8_t size) {
    uint8_t x = x_start;
    while(*str) {
        char ch = *str;
        if (ch >= 'a' && ch <= 'z') ch -= 32;
        if (ch >= 32 && ch <= 90) {
            uint8_t idx = ch - 32;
            for (uint8_t i = 0; i < 5; i++) {
                uint8_t byte = font5x7[idx][i];
                for (uint8_t j = 0; j < 8; j++) {
                    if ((byte >> j) & 0x01) {
                        for(uint8_t sx = 0; sx < size; sx++) {
                            for(uint8_t sy = 0; sy < size; sy++) {
                                ssd1306_DrawPixel(x + (i * size) + sx, y_start + (j * size) + sy, 1);
                            }
                        }
                    }
                }
            }
        }
        x += (6 * size);
        str++;
    }
}

/* Configuration Functions */

void SystemClock_Config(void) {
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0);
}

static void MX_I2C1_Init(void) {
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 400000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  HAL_I2C_Init(&hi2c1);
}

static void MX_GPIO_Init(void) {
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  // Laser (PB0) and Buzzer (PB1) - Outputs
  GPIO_InitStruct.Pin = LASER_PIN | BUZZER_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  // LDR (PA1) - Input
  GPIO_InitStruct.Pin = LDR_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(LDR_PORT, &GPIO_InitStruct);
}

void Error_Handler(void) { while(1); }
